using System;
using System.Runtime.InteropServices;
using System.Threading;

namespace De1ta
{

    // 随机数扩展类
    public static class RandomExtensions
    {
        // 生成高斯分布随机数(正态分布)
        public static double NextGaussian(this Random rand)
        {
            double u1 = 1.0 - rand.NextDouble();
            double u2 = 1.0 - rand.NextDouble();
            return Math.Sqrt(-2.0 * Math.Log(u1)) * Math.Sin(2.0 * Math.PI * u2);
        }
    }

    // 按键控制类
    public class InputControl
    {
        // 输入控制API
        [DllImport("user32.dll")]
        private static extern short GetAsyncKeyState(int vKey);
        [DllImport("user32.dll")]
        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, int dwExtraInfo);

        // 虚拟键码常量
        private const int
            VK_LBUTTON = 0x01,        // 鼠标左键
            VK_RBUTTON = 0x02,        // 鼠标右键
            VK_W = 0x57,              // W键
            VK_CAPITAL = 0x14,        // Caps Lock键
            VK_LSHIFT = 0xA0,         // Shift键
            VK_LMENU = 0xA4,          // Alt键
            KEY_PRESSED = 0x8000;     // 按键按下状态标志

        // 键盘事件常量
        private const uint
            KEY_DOWN_EVENT = 0x0000,  // 模拟按键按下
            KEY_UP_EVENT = 0x0002;    // 模拟按键释放

        // 按键状态变量
        private static int wPressCount = 0;                              // W键按下计数
        private static DateTime firstPressTime = DateTime.MinValue;      // 首次按下时间
        private static DateTime stutterDetectedTime = DateTime.MinValue; // 碎步检测时间
        private static bool isWPressed = false;                          // W键当前状态
        private static bool isStutterDetected = false;                   // 碎步检测标志
        private static bool lastLeftAndRightState = false;               // 跟踪屏息状态

        // 时间事件常量
        private const int
            TIME_WINDOW = 1500,       // 碎步检测时间窗口
            STUTTER_TIMEOUT = 2000;   // 等待Shift释放超时

        // 线程安全随机数 为每个线程生成唯一种子
        private static readonly ThreadLocal<Random> rand = new ThreadLocal<Random>(() => new Random(Guid.NewGuid().GetHashCode()));

        // 高斯随机延迟生成方法
        private static int GetStutterDelay()
        {
            // 高斯分布随机延迟
            double gaussian = rand.Value.NextGaussian();
            int delay;

            // 10%概率触发突发延迟
            if (rand.Value.NextDouble() < 0.10)              // 10%概率
            {
                delay = rand.Value.Next(101, 151);           // 101-151ms随机延迟
            }
            else
            {
                delay = (int)(gaussian * 20 + 50);           // 高斯分布参数：μ=50ms(中心点), σ=20ms(标准差) 

                // 添加噪声
                int noise = rand.Value.Next(-10, 11);        // ±10ms随机干扰
                delay += noise;                              // 应用噪声

                // 随机延迟范围
                delay = Math.Max(10, Math.Min(delay, 100));  // 最终限制到目标范围
            }

            return delay;
        }

        // 主控制循环
        public static void Start()
        {
            while (true)
            {

                // 检测W键与Shift键按下状态
                bool shiftPressed = (GetAsyncKeyState(VK_LSHIFT) & KEY_PRESSED) != 0;
                bool wCurrentPressed = (GetAsyncKeyState(VK_W) & KEY_PRESSED) != 0;

                // 碎步功能实现
                if (shiftPressed)
                {
                    if (isStutterDetected)  // 已检测到碎步
                    {
                        // 检查超时未松开Shift
                        if ((DateTime.Now - stutterDetectedTime).TotalMilliseconds > STUTTER_TIMEOUT)
                        {
                            wPressCount = 0;
                            firstPressTime = DateTime.MinValue;
                            isStutterDetected = false;
                            stutterDetectedTime = DateTime.MinValue;
                        }
                    }
                    else  // 未检测到碎步
                    {
                        // W键按下动作检测
                        if (wCurrentPressed && !isWPressed)
                        {
                            isWPressed = true;

                            // 重置计数条件(首次按下或超时)
                            if (wPressCount == 0 ||
                                (DateTime.Now - firstPressTime).TotalMilliseconds > TIME_WINDOW)
                            {
                                wPressCount = 1;
                                firstPressTime = DateTime.Now;
                            }
                            else
                            {
                                wPressCount++;

                                // 检测碎步条件(2次点击且在时间窗口内)
                                if (wPressCount >= 2 &&
                                    (DateTime.Now - firstPressTime).TotalMilliseconds <= TIME_WINDOW)
                                {
                                    isStutterDetected = true;
                                    stutterDetectedTime = DateTime.Now;  // 记录检测时间
                                }
                            }
                        }
                        // W键释放动作检测
                        else if (!wCurrentPressed && isWPressed)
                        {
                            isWPressed = false;
                        }

                        // 超时重置计数
                        else if (wPressCount > 0 &&
                                 (DateTime.Now - firstPressTime).TotalMilliseconds > TIME_WINDOW)
                        {
                            wPressCount = 0;
                            firstPressTime = DateTime.MinValue;
                        }
                    }
                }
                else  // Shift未按下状态处理
                {
                    // 松开Shift后触发Alt键
                    if (isStutterDetected)
                    {
                        Thread.Sleep(GetStutterDelay());                       // 使用高斯随机延迟
                        keybd_event((byte)VK_LMENU, 0x38, KEY_DOWN_EVENT, 0);  // 模拟Alt按下
                        Thread.Sleep(GetStutterDelay());                       // 使用高斯随机延迟
                        keybd_event((byte)VK_LMENU, 0x38, KEY_UP_EVENT, 0);    // 模拟Alt释放
                    }

                    // 重置所有状态
                    if (wPressCount > 0 || isStutterDetected)
                    {
                        wPressCount = 0;
                        firstPressTime = DateTime.MinValue;
                        isStutterDetected = false;
                        stutterDetectedTime = DateTime.MinValue;
                    }
                    isWPressed = false;
                }


                // 检测当前鼠标左右键状态
                bool leftPressed = (GetAsyncKeyState(VK_LBUTTON) & KEY_PRESSED) != 0;
                bool rightPressed = (GetAsyncKeyState(VK_RBUTTON) & KEY_PRESSED) != 0;
                bool bothPressed = leftPressed && rightPressed;

                // 屏息功能实现
                if (bothPressed && !lastLeftAndRightState)
                {
                    Thread.Sleep(GetStutterDelay());                     // 使用高斯随机延迟
                    keybd_event((byte)VK_CAPITAL, 0, KEY_DOWN_EVENT, 0); // 模拟Caps Lock按下
                }

                // 当任意一键松开时释放Caps Lock
                else if (!bothPressed && lastLeftAndRightState)
                {
                    Thread.Sleep(GetStutterDelay());                     // 使用高斯随机延迟
                    keybd_event((byte)VK_CAPITAL, 0, KEY_UP_EVENT, 0);   // 模拟Caps Lock释放
                }

                lastLeftAndRightState = bothPressed;                     // 更新状态跟踪

                // 主循环延迟(1-9ms)
                Thread.Sleep(rand.Value.Next(1, 10));
            }
        }
    }

    //程序入口类
    class Program
    {

        // 导入Win32 API函数用于隐藏控制台窗口
        [DllImport("user32.dll")] static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        [DllImport("kernel32.dll")] static extern IntPtr GetConsoleWindow();

        // 导入Win32 API的消息框函数
        [DllImport("user32.dll", CharSet = CharSet.Unicode)] static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);

        // 程序入口点
        static void Main(string[] args)
        {
            // 获取控制台窗口句柄并隐藏它
            IntPtr consoleWindowHandle = GetConsoleWindow();
            if (consoleWindowHandle != IntPtr.Zero)
            {
                // 0表示隐藏窗口
                ShowWindow(consoleWindowHandle, 0);
            }
            
            MessageBox(IntPtr.Zero, "        De1ta is ready.", "Tips", 0);

            // 启动主控制循环
            InputControl.Start();
        }
    }
}
