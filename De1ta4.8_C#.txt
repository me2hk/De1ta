using System;
using System.Runtime.InteropServices;
using System.Threading;
using System.Diagnostics;

// 主空间
namespace De1ta
{
    // 随机数扩展类
    public static class RandomExtensions
    {
        // 生成高斯分布随机数(正态分布)
        public static double NextGaussian(this Random rand)
        {
            double u1 = 1.0 - rand.NextDouble();
            double u2 = 1.0 - rand.NextDouble();
            return Math.Sqrt(-2.0 * Math.Log(u1)) * Math.Sin(2.0 * Math.PI * u2);
        }
    }

    // 按键控制类
    public class InputControl
    {
        // 输入控制API
        [DllImport("user32.dll")]
        private static extern short GetAsyncKeyState(int vKey);

        [DllImport("user32.dll")]
        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, int dwExtraInfo);

        // 虚拟键码常量
        private const int
            VK_LBUTTON = 0x01,        // 鼠标左键
            VK_RBUTTON = 0x02,        // 鼠标右键
            VK_W = 0x57,              // W键
            VK_CAPITAL = 0x14,        // Caps Lock键
            VK_LSHIFT = 0xA0,         // Shift键
            VK_LMENU = 0xA4,          // Alt键
            KEY_PRESSED = 0x8000;     // 按键按下状态标志

        // 键盘事件常量
        private const uint
            KEY_DOWN_EVENT = 0x0000,  // 模拟按键按下
            KEY_UP_EVENT = 0x0002;    // 模拟按键释放

        // 按键状态变量
        private static int wPressCount = 0;                              // W键按下计数
        private static DateTime firstPressTime = DateTime.MinValue;      // 首次按下时间
        private static DateTime stutterDetectedTime = DateTime.MinValue; // 碎步检测时间
        private static bool isWPressed = false;                          // W键当前状态
        private static bool isStutterDetected = false;                   // 碎步检测标志
        private static bool lastLeftAndRightState = false;               // 鼠标跟踪状态
        private static bool isRunning = false;                           // 主循环运行标志

        // 时间事件常量
        private const int
            TIME_WINDOW = 1500,       // 碎步检测时间窗口
            STUTTER_TIMEOUT = 2000;   // 等待Shift释放超时

        // 线程安全随机数 为每个线程生成唯一种子
        private static readonly ThreadLocal<Random> rand =
            new ThreadLocal<Random>(() => new Random(Guid.NewGuid().GetHashCode()));

        // 高斯随机延迟生成方法
        private static int GetStutterDelay()
        {
            // 高斯分布随机延迟
            double gaussian = rand.Value.NextGaussian();
            int delay;

            // 10%概率触发突发延迟
            if (rand.Value.NextDouble() < 0.10)                 // 10%概率
            {
                delay = rand.Value.Next(101, 151);              // 101-151ms随机延迟
            }
            else
            {
                delay = (int)(gaussian * 20 + 50);              // 高斯分布参数:μ=50ms(中心点),σ=20ms(标准差) 

                // 添加噪声
                int noise = rand.Value.Next(-10, 11);           // ±10ms随机干扰
                delay += noise;                                 // 应用噪声

                // 随机延迟范围
                delay = Math.Max(10, Math.Min(delay, 100));     // 最终限制到目标范围
            }

            return delay;
        }

        // 设置运行状态
        public static void SetRunningState(bool running)
        {
            // 更新主循环运行标志
            isRunning = running;

            // 如果设置为不运行状态，则重置所有相关状态变量
            if (!running)
            {
                // 重置所有状态
                wPressCount = 0;                                // 重置W键按下计数
                firstPressTime = DateTime.MinValue;             // 重置首次按下时间
                stutterDetectedTime = DateTime.MinValue;        // 重置碎步检测时间
                isWPressed = false;                             // 重置W键当前状态
                isStutterDetected = false;                      // 重置碎步检测标志
                lastLeftAndRightState = false;                  // 重置鼠标跟踪状态
            }
        }

        // 主循环
        public static void Start()
        {
            // 无限循环，持续监控和处理按键输入
            while (true)
            {
                // 检查是否应该运行
                if (!isRunning)
                {
                    Thread.Sleep(GetStutterDelay());            // 使用高斯随机延迟
                    continue;                                   // 跳过当前循环迭代
                }

                // 检测W键与Shift键按下状态
                bool shiftPressed = (GetAsyncKeyState(VK_LSHIFT) & KEY_PRESSED) != 0;
                bool wCurrentPressed = (GetAsyncKeyState(VK_W) & KEY_PRESSED) != 0;

                // 碎步功能实现
                if (shiftPressed)                               // 如果Shift键被按下
                {
                    if (isStutterDetected)                      // 已检测到碎步
                    {
                        // 检查超时未松开Shift
                        if ((DateTime.Now - stutterDetectedTime).TotalMilliseconds > STUTTER_TIMEOUT)
                        {
                            wPressCount = 0;                             // 重置W键按下计数
                            firstPressTime = DateTime.MinValue;          // 重置首次按下时间
                            stutterDetectedTime = DateTime.MinValue;     // 重置碎步检测时间
                            isStutterDetected = false;                   // 重置碎步检测标志
                        }
                    }
                    else                                        // 未检测到碎步
                    {
                        // W键按下动作检测
                        if (wCurrentPressed && !isWPressed)     // W键当前按下且之前未按下
                        {
                            isWPressed = true;                  // 更新W键状态为按下

                            // 重置计数条件(首次按下或超时)
                            if (wPressCount == 0 ||             // 首次按下W键
                                (DateTime.Now - firstPressTime).TotalMilliseconds > TIME_WINDOW)
                            {
                                wPressCount = 1;                // 重置计数为1
                                firstPressTime = DateTime.Now;  // 记录首次按下时间
                            }
                            else                                // 非首次按下且在时间窗口内
                            {
                                wPressCount++;                  // 增加按下计数

                                // 检测碎步条件(2次点击且在时间窗口内)
                                if (wPressCount >= 2 &&         // 至少按下2次
                                    (DateTime.Now - firstPressTime).TotalMilliseconds <= TIME_WINDOW)
                                {
                                    isStutterDetected = true;            // 标记已检测到碎步
                                    stutterDetectedTime = DateTime.Now;  // 记录检测时间
                                }
                            }
                        }
                        // W键释放动作检测
                        else if (!wCurrentPressed && isWPressed)   // W键当前未按下且之前按下
                        {
                            isWPressed = false;                    // 更新W键状态为释放
                        }

                        // 超时重置计数
                        else if (wPressCount > 0 &&
                                 (DateTime.Now - firstPressTime).TotalMilliseconds > TIME_WINDOW)
                        {
                            wPressCount = 0;                       // 重置按下计数
                            firstPressTime = DateTime.MinValue;    // 重置首次按下时间
                        }
                    }
                }
                else                                               // Shift未按下状态处理
                {
                    // 松开Shift后触发Alt键
                    if (isStutterDetected)                         // 如果已检测到碎步
                    {
                        Thread.Sleep(GetStutterDelay());                       // 使用高斯随机延迟
                        keybd_event((byte)VK_LMENU, 0x38, KEY_DOWN_EVENT, 0);  // 模拟Alt按下
                        Thread.Sleep(GetStutterDelay());                       // 使用高斯随机延迟
                        keybd_event((byte)VK_LMENU, 0x38, KEY_UP_EVENT, 0);    // 模拟Alt释放
                    }

                    // 重置所有状态
                    if (wPressCount > 0 || isStutterDetected)
                    {
                        wPressCount = 0;                                       // 重置W键按下计数
                        firstPressTime = DateTime.MinValue;                    // 重置首次按下时间
                        stutterDetectedTime = DateTime.MinValue;               // 重置碎步检测时间
                        isStutterDetected = false;                             // 重置碎步检测标志
                    }

                    isWPressed = false;                            // 重置W键当前状态
                }

                // 检测当前鼠标左右键状态
                bool leftPressed = (GetAsyncKeyState(VK_LBUTTON) & KEY_PRESSED) != 0;
                bool rightPressed = (GetAsyncKeyState(VK_RBUTTON) & KEY_PRESSED) != 0;
                bool bothPressed = leftPressed && rightPressed;

                // 屏息功能实现
                if (bothPressed && !lastLeftAndRightState)               // 如果同时按下左右键且之前未同时按下
                {
                    Thread.Sleep(GetStutterDelay());                     // 使用高斯随机延迟
                    keybd_event((byte)VK_CAPITAL, 0, KEY_DOWN_EVENT, 0); // 模拟Caps Lock按下
                }

                // 当任意一键松开时释放Caps Lock
                else if (!bothPressed && lastLeftAndRightState)          // 如果未同时按下左右键但之前同时按下
                {
                    Thread.Sleep(GetStutterDelay());                     // 使用高斯随机延迟
                    keybd_event((byte)VK_CAPITAL, 0, KEY_UP_EVENT, 0);   // 模拟Caps Lock释放
                }

                lastLeftAndRightState = bothPressed;                     // 更新鼠标跟踪状态

                // 主循环延迟(1-9ms)
                Thread.Sleep(rand.Value.Next(1, 10));
            }
        }
    }

    // 进程监控类
    public static class ProcessMonitor
    {
        private static Thread monitorThread;        // 监控线程,用于在后台持续监控目标进程
        private static bool isMonitoring = false;   // 监控状态标志

        // 启动进程监控
        public static void StartMonitoring()
        {
            // 如果已经在监控中，则直接返回，避免重复启动
            if (isMonitoring) return;

            isMonitoring = true;                  // 设置监控状态为true

            // 创建并启动监控线程，设置为后台线程
            monitorThread = new Thread(MonitorProcess) { IsBackground = true };
            monitorThread.Start();
        }

        // 停止进程监控
        public static void StopMonitoring()
        {
            isMonitoring = false;                 // 设置监控状态为false

            // 如果监控线程存在且仍在运行，等待其结束
            if (monitorThread != null && monitorThread.IsAlive)
            {
                monitorThread.Join(1000);         // 等待线程结束
            }
        }

        // 监控进程方法
        private static void MonitorProcess()
        {
            string targetProcess = "notepad";     // 监控的进程名

            // 持续监控循环
            while (isMonitoring)
            {
                // 检查指定名称的进程是否存在
                bool processExists = Process.GetProcessesByName(targetProcess).Length > 0;

                // 根据进程是否存在设置输入控制类的运行状态
                InputControl.SetRunningState(processExists);

                // 每隔1秒检查一次
                Thread.Sleep(1000);
            }
        }
    }

    // 程序入口类
    class Program
    {
        // 主入口
        static void Main(string[] args)
        {
            // 启动进程监控
            ProcessMonitor.StartMonitoring();

            // 启动主控制循环
            Thread controlThread = new Thread(InputControl.Start) { IsBackground = true };
            controlThread.Start();

            // 等待控制线程结束(程序退出时)
            controlThread.Join();
        }
    }
}
