using System;
using System.Runtime.InteropServices;
using System.Threading;
using System.Diagnostics;

// 主空间
namespace De1ta
{
    class Program
    {
        // 输入控制 API
        [DllImport("user32.dll")]
        private static extern short GetAsyncKeyState(int vKey);

        [DllImport("user32.dll")]
        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, int dwExtraInfo);

        // 消息框 API
        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);

        // 虚拟键码常量
        private const int
            VK_LBUTTON = 0x01,                                                 // 鼠标左键
            VK_RBUTTON = 0x02,                                                 // 鼠标右键
            VK_CAPITAL = 0x14,                                                 // Caps Lock键
            VK_HOME = 0x24,                                                    // Home键
            KEY_PRESSED = 0x8000;                                              // 按键状态标志

        // 键盘事件常量
        private const uint
            KEY_DOWN_EVENT = 0x0000,                                           // 模拟按键按下
            KEY_UP_EVENT = 0x0002;                                             // 模拟按键释放

        // 按键状态变量
        private static bool lastLeftAndRightState = false;                     // 鼠标左右键状态跟踪
        private static bool lastHomeState = false;                             // Home键状态跟踪
        private static bool isCapsLockSimulated = false;                       // Caps Lock键状态跟踪
        private static Stopwatch holdTimer = new Stopwatch();                  // 按键时间计时器
        private static int currentHoldThreshold = 0;                           // 按键时间阈值

        // 线程安全随机数,为每个线程生成唯一种子
        private static readonly ThreadLocal<Random> rand = new ThreadLocal<Random>(() => new Random(Guid.NewGuid().GetHashCode()));
        
        // 随机按键时间阈值生成方法
        private static int GetRandomHoldThreshold()
        {
            return rand.Value.Next(150, 201); // 150~200ms随机范围
        }

        // 随机数扩展生成方法
        private static double NextGaussian(Random random)
        {
            double u1 = 1.0 - random.NextDouble();
            double u2 = 1.0 - random.NextDouble();
            return Math.Sqrt(-2.0 * Math.Log(u1)) * Math.Sin(2.0 * Math.PI * u2);
        }

        // 高斯随机延迟生成方法
        private static int GetStutterDelay()
        {
            // 高斯分布随机延迟
            double gaussian = NextGaussian(rand.Value);
            int delay;

            // 20%概率触发突发延迟
            if (rand.Value.NextDouble() < 0.20)                                // 20%概率
            {
                delay = rand.Value.Next(100, 151);                             // 100-150ms随机延迟
            }
            else
            {
                delay = (int)(gaussian * 20 + 50);                             // 高斯分布参数:μ=50ms(中心点),σ=20ms(标准差) 

                // 添加噪声
                int noise = rand.Value.Next(-10, 11);                          // ±10ms随机干扰
                delay += noise;                                                // 应用噪声

                // 随机延迟范围
                delay = Math.Max(1, Math.Min(delay, 100));                     // 最终限制到目标范围
            }

            return delay;
        }

        // 程序信息显示方法
        private static void ShowProcessInfo()
        {
            Process currentProcess = Process.GetCurrentProcess();              // 获取当前正在运行的进程
            string processName = currentProcess.ProcessName;                   // 获取当前进程的名称
            int processId = currentProcess.Id;                                 // 获取当前进程的PID

            string message = "         版本:  V5.1.0" + "\n" + "         进程:  " + processName + ".exe" + "\n" + "         PID:   " + processId;

            // 使用MessageBox显示信息
            MessageBox(IntPtr.Zero, message, "信息", 0);
        }

        // 主循环
        private static void Start()
        {
            // 无限循环，持续监控和处理按键输入
            while (true)
            {

                // 检测鼠标左右键状态
                bool leftPressed = (GetAsyncKeyState(VK_LBUTTON) & KEY_PRESSED) != 0;
                bool rightPressed = (GetAsyncKeyState(VK_RBUTTON) & KEY_PRESSED) != 0;
                bool bothPressed = leftPressed && rightPressed;

                // 检测Home键状态
                bool homePressed = (GetAsyncKeyState(VK_HOME) & KEY_PRESSED) != 0;

                // 屏息功能实现(鼠标左右键)
                if (bothPressed && !lastLeftAndRightState)                     // 如果同时按下鼠标左右键
                {
                    holdTimer.Restart();                                       // 按键计时器开始
                    currentHoldThreshold = GetRandomHoldThreshold();           // 设置随机按压时间阈值
                }
                else if (bothPressed && lastLeftAndRightState)                 // 如果持续按住鼠标左右键
                {
                    // 如果持续按住鼠标左右键超过随机阈值且尚未模拟按下
                    if (holdTimer.IsRunning && holdTimer.ElapsedMilliseconds >= currentHoldThreshold && !isCapsLockSimulated)
                    {
                        Thread.Sleep(GetStutterDelay());                       // 使用高斯随机延迟
                        keybd_event((byte)VK_CAPITAL, 0, KEY_DOWN_EVENT, 0);   // 模拟Caps Lock按下
                        isCapsLockSimulated = true;                            // 更新Caps Lock按下标记
                        holdTimer.Stop();                                      // 按键计时器停止
                    }
                }

                // 当任意一键松开时释放Caps Lock
                else if (!bothPressed && lastLeftAndRightState)                // 如果松开任意鼠标左右键
                {
                    // 只有Caps Lock标记为按下时Caps Lock时才释放
                    if (isCapsLockSimulated)
                    {
                        Thread.Sleep(GetStutterDelay());                       // 使用高斯随机延迟
                        keybd_event((byte)VK_CAPITAL, 0, KEY_UP_EVENT, 0);     // 模拟Caps Lock释放
                        isCapsLockSimulated = false;                           // 重置Caps Lock按下标记
                    }
                    holdTimer.Reset();                                         // 重置按键时间计时器
                    currentHoldThreshold = 0;                                  // 重置按键时间阈值
                }
                
                // 信息功能实现(Home键)
                if (homePressed && !lastHomeState)
                {
                    ShowProcessInfo(); // 显示程序信息
                }

                lastLeftAndRightState = bothPressed;                           // 更新鼠标左右键状态跟踪
                lastHomeState = homePressed;                                   // 更新Home键状态跟踪

                // 主循环延迟(1-9ms)
                Thread.Sleep(rand.Value.Next(1, 10));
            }
        }

        static void Main(string[] args)
        {
            // 启动主循环
            Start();
        }
    }
}