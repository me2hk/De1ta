#include "pch.h"  // 预编译头文件
#include <Windows.h>
#include <random>
#include <chrono>
#include <thread>
#include <cmath>
#include <iostream>
#include <ctime>

using namespace std;

// 定义M_PI常量（在某些编译器中未定义）
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// 使用预处理器定义常量而不是const声明
#define VK_LBUTTON 0x01        // 鼠标左键
#define VK_RBUTTON 0x02        // 鼠标右键
#define VK_W 0x57              // W键
#define VK_CAPITAL 0x14        // Caps Lock键
#define VK_LSHIFT 0xA0         // Shift键
#define VK_LMENU 0xA4          // Alt键
#define KEY_PRESSED 0x8000     // 按键按下状态标志

// 键盘事件常量
#define KEY_DOWN_EVENT 0x0000  // 模拟按键按下
#define KEY_UP_EVENT 0x0002    // 模拟按键释放

// 时间窗口常量(毫秒)
#define TIME_WINDOW 1500       // 碎步检测时间窗口
#define STUTTER_TIMEOUT 2000   // 等待Shift释放超时

// 随机数扩展函数
namespace RandomExtensions
{
    // 生成高斯分布随机数(正态分布)
    double NextGaussian()
    {
        static thread_local mt19937 generator(GetTickCount());
        uniform_real_distribution<double> distribution(0.0, 1.0);

        double u1 = 1.0 - distribution(generator);
        double u2 = 1.0 - distribution(generator);
        return sqrt(-2.0 * log(u1)) * sin(2.0 * M_PI * u2);
    }
}

// 按键控制类
class InputControl
{
private:
    // 输入控制API
    static short GetAsyncKeyState(int vKey) { return ::GetAsyncKeyState(vKey); }
    static void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, DWORD dwExtraInfo) { ::keybd_event(bVk, bScan, dwFlags, dwExtraInfo); }

    // 按键状态跟踪变量
    static int wPressCount;                              // W键按下计数
    static chrono::system_clock::time_point firstPressTime;      // 首次按下时间
    static chrono::system_clock::time_point stutterDetectedTime; // 碎步检测时间
    static bool isWPressed;                          // W键当前状态
    static bool isStutterDetected;                   // 碎步检测标志
    static bool lastLeftAndRightState;               // 跟踪屏息状态

    // 高斯随机延迟生成方法
    static int GetStutterDelay()
    {
        // 高斯分布随机延迟
        double gaussian = RandomExtensions::NextGaussian();
        int delay;

        // 10%概率触发突发延迟
        if (rand() / (double)RAND_MAX < 0.10)              // 10%概率
        {
            delay = rand() % 51 + 101;           // 101-151ms随机延迟
        }
        else
        {
            delay = (int)(gaussian * 20 + 50);           // 高斯分布参数：μ=50ms(中心点), σ=20ms(标准差) 

            // 添加噪声
            int noise = rand() % 21 - 10;        // ±10ms随机干扰
            delay += noise;                              // 应用噪声

            // 随机延迟范围限制
            delay = max(10, min(delay, 100));  // 最终限制到目标范围
        }

        return delay;
    }

public:
    // 主控制循环
    static DWORD WINAPI Start(LPVOID lpParam)
    {
        while (true)
        {
            // 检测W键与Shift键按下状态
            bool shiftPressed = (GetAsyncKeyState(VK_LSHIFT) & KEY_PRESSED) != 0;
            bool wCurrentPressed = (GetAsyncKeyState(VK_W) & KEY_PRESSED) != 0;

            // 碎步功能实现
            if (shiftPressed)
            {
                if (isStutterDetected)  // 已检测到碎步
                {
                    // 检查超时未松开Shift
                    auto now = chrono::system_clock::now();
                    if (chrono::duration_cast<chrono::milliseconds>(now - stutterDetectedTime).count() > STUTTER_TIMEOUT)
                    {
                        wPressCount = 0;
                        firstPressTime = chrono::system_clock::time_point();
                        isStutterDetected = false;
                        stutterDetectedTime = chrono::system_clock::time_point();
                    }
                }
                else  // 未检测到碎步
                {
                    // W键按下动作检测
                    if (wCurrentPressed && !isWPressed)
                    {
                        isWPressed = true;

                        // 重置计数条件(首次按下或超时)
                        auto now = chrono::system_clock::now();
                        if (wPressCount == 0 ||
                            chrono::duration_cast<chrono::milliseconds>(now - firstPressTime).count() > TIME_WINDOW)
                        {
                            wPressCount = 1;
                            firstPressTime = now;
                        }
                        else
                        {
                            wPressCount++;

                            // 检测碎步条件(2次点击且在时间窗口内)
                            if (wPressCount >= 2 &&
                                chrono::duration_cast<chrono::milliseconds>(now - firstPressTime).count() <= TIME_WINDOW)
                            {
                                isStutterDetected = true;
                                stutterDetectedTime = now;  // 记录检测时间
                            }
                        }
                    }
                    // W键释放动作检测
                    else if (!wCurrentPressed && isWPressed)
                    {
                        isWPressed = false;
                    }

                    // 超时重置计数
                    else if (wPressCount > 0)
                    {
                        auto now = chrono::system_clock::now();
                        if (chrono::duration_cast<chrono::milliseconds>(now - firstPressTime).count() > TIME_WINDOW)
                        {
                            wPressCount = 0;
                            firstPressTime = chrono::system_clock::time_point();
                        }
                    }
                }
            }
            else  // Shift未按下状态处理
            {
                // 松开Shift后触发Alt键
                if (isStutterDetected)
                {
                    this_thread::sleep_for(chrono::milliseconds(GetStutterDelay()));      // 使用高斯随机延迟
                    keybd_event((BYTE)VK_LMENU, 0x38, KEY_DOWN_EVENT, 0);  // 模拟Alt按下
                    this_thread::sleep_for(chrono::milliseconds(GetStutterDelay()));      // 使用高斯随机延迟
                    keybd_event((BYTE)VK_LMENU, 0x38, KEY_UP_EVENT, 0);    // 模拟Alt释放
                }

                // 重置所有状态
                if (wPressCount > 0 || isStutterDetected)
                {
                    wPressCount = 0;
                    firstPressTime = chrono::system_clock::time_point();
                    isStutterDetected = false;
                    stutterDetectedTime = chrono::system_clock::time_point();
                }
                isWPressed = false;
            }

            // 检测当前鼠标左右键状态
            bool leftPressed = (GetAsyncKeyState(VK_LBUTTON) & KEY_PRESSED) != 0;
            bool rightPressed = (GetAsyncKeyState(VK_RBUTTON) & KEY_PRESSED) != 0;
            bool bothPressed = leftPressed && rightPressed;

            // 屏息功能实现
            if (bothPressed && !lastLeftAndRightState)
            {
                this_thread::sleep_for(chrono::milliseconds(GetStutterDelay()));      // 使用高斯随机延迟
                keybd_event((BYTE)VK_CAPITAL, 0, KEY_DOWN_EVENT, 0); // 模拟Caps Lock按下
            }

            // 当任意一键松开时释放Caps Lock
            else if (!bothPressed && lastLeftAndRightState)
            {
                this_thread::sleep_for(chrono::milliseconds(GetStutterDelay()));      // 使用高斯随机延迟
                keybd_event((BYTE)VK_CAPITAL, 0, KEY_UP_EVENT, 0);   // 模拟Caps Lock释放
            }

            lastLeftAndRightState = bothPressed;                     // 更新状态跟踪

            // 主循环延迟(1-9ms)
            this_thread::sleep_for(chrono::milliseconds(rand() % 9 + 1));
        }
        return 0;
    }
};

// 初始化静态成员变量
int InputControl::wPressCount = 0;
chrono::system_clock::time_point InputControl::firstPressTime = chrono::system_clock::time_point();
chrono::system_clock::time_point InputControl::stutterDetectedTime = chrono::system_clock::time_point();
bool InputControl::isWPressed = false;
bool InputControl::isStutterDetected = false;
bool InputControl::lastLeftAndRightState = false;

// DLL入口函数
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        // 初始化随机数生成器
        srand(static_cast<unsigned int>(time(NULL)));

        // 启动控制循环线程
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)InputControl::Start, NULL, 0, NULL);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
